{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-10 13:19:43 "},"proto/icmp.html":{"url":"proto/icmp.html","title":"ICMP","keywords":"","body":" ICMP简介 ICMP协议 ICMP协议头部 ICMP常见的报文类型 ICMP In IP 常见的ICMP报文 ICMP典型运用 ping traceroute ICMP简介 ICMP全名为(INTERNET CONTROL MESSAGE PROTOCOL)网络控制消息协议. ICMP产生的背景:在网络体系结构的各层次中，都需要控制，而不同的层次有不同的分工和控制内容，任何控制都是建立在信息的基础之上的. IP层的控制功能是最复杂的，主要负责差错控制、拥塞控制等。 在基于IP数据报的网络体系中，网关必须自己处理数据报的传输工作，而IP协议自身没有内在机制来获取差错信息并处理。为了处理这些错误，TCP/IP设计了ICMP协议，当某个网关发现传输错误时，立即向信源主机发送ICMP报文，报告出错信息，让信源主机采取相应处理措施。它是一种差错和控制报文协议，不仅用于传输差错报文，还传输控制报文。 ICMP 所在的网络层级及其作用：ICMP属于TCP/IP协议族，工作在网络层（第三层），用于在IP主机、路由器之间传递控制消息。所谓的控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP的主要作用是主机探测,路由维护,路由选择,流量控制。ICMP协议与ARP协议不同，ICMP靠IP协议来完成任务，所以ICMP报文中要封装IP头部。它与传输层协议（如TCP和UDP）的目的不同，一般不用来在端系统之间传送数据，不被用户网络程序直接使用，除了想Ping和Tracert这样的诊断程序。 ICMP协议 ICMP协议头部 ICMP协议封装在IP协议中，ICMP有很多报文类型，每一个报文类型又各自不相同，所以无法找到一个统一的报文格式来进行说明，但是他们的前四个字节的报文格式是相同的。 ![icmp头部](../pic/icmp/icmp_head.png) 类型：一个 8 位类型字段，表示 ICMP 数据包类型; 功能代码：一个 8 位代码域，表示指定类型中的一个功能，如果一个类型中只有一种功能，代码域置为 0; 检验和：数据包中 ICMP 部分上的一个 16 位检验和; ``` icmp head ``` ```c /* * Struct icmphdr_common represents the common part of the icmphdr and icmp6hdr * structures. */ struct icmphdr_common { __u8 type; __u8 code; __sum16 cksum; }; ``` ICMP常见的报文类型 ICMP的报文分为两类，一类是ICMP询问报文，一类是ICMP差错报告报文 ICMP In IP ICMP报文包含在IP数据报中，IP报头在ICMP报文的最前面。一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。当IP报头中的协议字段值为1时，就说明这是一个ICMP报文。ICMP报头如下图所示。 ![icmp封装](../pic/icmp/icmp_ip.png) 各字段说明 类型： 占一字节，标识ICMP报文的类型，目前已定义了14种，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文。 代码： 占一字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型。用于标示在特定的功能下不同的错误代码。例如，目标不可达的类型中，标示具体不可达的信息。 校验和： 这是对包括ICMP报文数据部分在内的`整个ICMP数据报的校验和`，以检验报文在传输过程中是否出现了差错。其`计算方法`与在我们介绍IP报头中的校验和计算方法是一样的。 标识： 占两字节，用于`标识本ICMP进程`，但仅适用于`回显请求和应答ICMP报文`，对于目标不可达ICMP报文和超时ICMP报文等，该字段的值为0。 ``` /linux/in.h /* Standard well-defined IP protocols. */ enum { IPPROTO_IP = 0, /* Dummy protocol for TCP */ #define IPPROTO_IP IPPROTO_IP IPPROTO_ICMP = 1, /* Internet Control Message Protocol */ #define IPPROTO_ICMP IPPROTO_ICMP IPPROTO_IGMP = 2, /* Internet Group Management Protocol */ #define IPPROTO_IGMP IPPROTO_IGMP IPPROTO_IPIP = 4, /* IPIP tunnels (older KA9Q tunnels use 94) */ #define IPPROTO_IPIP IPPROTO_IPIP IPPROTO_TCP = 6, /* Transmission Control Protocol */ #define IPPROTO_TCP IPPROTO_TCP IPPROTO_EGP = 8, /* Exterior Gateway Protocol */ #define IPPROTO_EGP IPPROTO_EGP IPPROTO_PUP = 12, /* PUP protocol */ #define IPPROTO_PUP IPPROTO_PUP IPPROTO_UDP = 17, /* User Datagram Protocol */ ``` 常见的ICMP报文 相应请求： 我们日常进行的Ping操作中就包括了相应请求（类型字段值为8）和应答（类型字段值为0）ICMP报文。一台主机向一个节点发送一个类型字段值为8的ICMP报文，如果途中没有异常（如果没有被路由丢弃，目标不回应ICMP或者传输失败），则目标返回类型字段值为0的ICMP报文，说明这台主机存在。 目标不可达，源抑制和超时报文： 这三种报文的格式是一样的。目标不可到达报文（类型值为3）在路由器或者主机不能传递数据时使用。例如我们要连接对方一个不存在的系统端口（端口号小于1024）时，将返回类型字段值3、代码字段值为3的ICMP报文。常见的不可到达类型还有网络不可到达（代码字段值为0）、主机不可达到（代码字段值为1）、协议不可到达（代码字段值为2）等等。 源抑制报文（类型字段值为4，代码字段值为0）： 则充当一个控制流量的角色，通知主机减少数据报流量。由于ICMP没有回复传输的报文，所以只要停止该报文，主机就会逐渐恢复传输速率。最后，无连接方式网络的问题就是数据报回丢失，或者长时间在网络游荡而找不到目标，或者拥塞导致主机在规定的时间内无法重组数据报分段，这时就要触发ICMP超时报文的产生。 超时报文 （类型字段值为11）的代码域有两种取值：代码字段值为0表示传输超时，代码字段值为1表示分段重组超时。 时间戳请求： 时间戳请求报文（类型值字段13）和时间戳应答报文（类型值字段14）用于测试两台主机之间数据报来回一次的传输时间。传输时，主机填充原始时间戳，接受方收到请求后填充接受时间戳后以类型值字段14的报文格式返回，发送方计算这个时间差。有些系统不响应这种报文。 ICMP典型应用 ping ICMP的一个典型应用是Ping。Ping是检测网络连通性的常用工具，同时也能够收集其他相关信息。用户可以在Ping命令中指定不同参数，如ICMP报文长度、发送的ICMP报文个数、等待回复响应的超时时间等，设备根据配置的参数来构造并发送ICMP报文，进行Ping测试 ping命令执行的时候，源主机首先会构建一个ICMP请求数据包，ICMP数据包内包含多个字段。最重要的是两个，第一个是类型字段，对于请求数据包而言该字段为8；另外一个是顺序号，主要用于区分连续ping的时候发出的多个数据包。每发出一个请求数据包，顺序号就会自动加1.为了能够计算往返时间RTT，它会在报文的数据部分插入发送时间。 然后，由ICMP协议将这个数据包连同地址192.168.1.2一起交给IP层，IP层将以192.168.1.2作为目的地址，本机IP地址作为源地址，加上一些其它控制信息，构建一个IP数据包。 接下来，需要加入MAC头。如果在本机ARP映射表中找出IP地址192.168.1.2所对应的MAC地址，则可以直接使用；如果没有，则需要发送ARP协议查询MAC地址，获得MAC地址后，由数据链路层构建一个数据帧，目的地址是IP层传过来的MAC地址，源地址则是本机的MAC地址；还要附加上一些控制信息，依据以太网的介质访问规则，将他们传送出去。 主机B收到这个数据帧后，先检查它的目的MAC地址，并和本机的MAC地址对比，如果符合则接收，否则就丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层。同样IP层检查后，将有用的信息提取后交给ICMP协议。 主机B会构建一个ICMP应答包，应答数据包的类型字段为0，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机A。 在规定的时间内，源主机如果没有接到ICMP的应答包，则说明目标主机不可达，如果接收到了ICMP应答包，则说明目标主机可达。 Ping常用的配置参数说明如下： 1. -a source-ip-address指定发送ICMP ECHO-REQUEST报文的源IP地址。如果不指定源IP地址，将采用出接口的IP地址作为ICMP ECHO-REQUEST报文发送的源地址。 2. -c count指定发送ICMP ECHO-REQUEST报文次数。缺省情况下发送5个ICMP ECHO-REQUEST报文。 3. -h ttl-value指定TTL的值。缺省值是255。 4. -t timeout指定发送完ICMP ECHO-REQUEST后，等待ICMP ECHO-REPLY的超时时间。 Ping命令的输出信息中包括目的地址、ICMP报文长度、序号、TTL值、以及往返时间。序号是包含在Echo回复消息（Type=0）中的可变参数字段，TTL和往返时间包含在消息的IP头中。 Traceroute ICMP的另一个典型应用是Traceroute。Traceroute基于报文头中的TTL值来逐跳跟踪报文的转发路径。为了跟踪到达某特定目的地址的路径，源端首先将报文的TTL值设置为1。该报文到达第一个节点后，TTL超时，于是该节点向源端发送TTL超时消息，消息中携带时间戳。然后源端将报文的TTL值设置为2，报文到达第二个节点后超时，该节点同样返回TTL超时消息，以此类推，直到报文到达目的地。这样，源端根据返回的报文中的信息可以跟踪到报文经过的每一个节点，并根据时间戳信息计算往返时间。 Traceroute是检测网络丢包及时延的有效手段，同时可以帮助管理员发现网络中的路由环路。 Traceroute常用的配置参数说明如下： 1. -a source-ip-address指定Traceroute报文的源地址。 2. -f first-ttl指定初始TTL。缺省值是1。 3. -m max-ttl指定最大TTL。缺省值是30。 4. -name使能显示每一跳的主机名。 5. -p port指定目的主机的UDP端口号。 Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-10 16:10:19 "},"proto/tcpip.html":{"url":"proto/tcpip.html","title":"数据包格式","keywords":"","body":" 网络协议栈 以太帧 IP udp tcp http 网络协议栈 协议栈 因特网协议栈共有五层： 应用层，是网络应用程序及其应用层协议存留的地方。因特网的应用层包括许多协议，常见的有HTTP(它为web文档提供了请求和传送)、SMTP(它提供了电子邮件报文的传输)和FTP(它提供了两个端系统之间的文件传送)。 传输层，负责为信源和信宿提供应用程序进程（包括同一终端上的不同进程）间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。 网络层，负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。 链路层，负责将IP数据报封装成合适在物理网络上传输的帧格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。 物理层，负责将比特流在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。 以太帧 以太帧数据包格式 由于物理层更多的是与物理介质有关，所以直接从链路层开始分析。 在链路层中，使用的最多的是以太网，而以太网帧因为历史原因存在多个版本，这里采用IEEE802.3以太网帧格式。 ![链路层数据包](../pic/proto/eth.png) * Preamble 前导码，7个字节，用于数据传输过程中的双方发送、接收的速率的同步 * SFD：帧开始符，1个字节，表明下一个字节开始是真实数据（目的MAC地址） * dst MAC：目的MAC地址，6个字节，指明帧的接受者 * src MAC：源MAC地址，6个字节，指明帧的发送者 * Length：长度，2个字节，指明该帧`数据字段的长度`，但不代表数据字段长度能够达到（2^16）字节 * Type：类型，2个字节，指明帧中`数据的协议类型`，比如常见的IPv4中ip协议采用0x0800 * Data and Pad：数据与填充，46~1500个字节，包含了上层协议传递下来的数据，如果加入数据字段后帧长度不够64字节，会在数据字段加入“填充”至达到64字节 * FCS：帧校验序列，4个字节，对接收网卡（主要是检测Data and Pad字段）提供判断是否传输错误的一种方法，如果发现错误，丢弃此帧。 目前最为流行的用于FCS的算法是循环冗余校验（cyclic redundancy check –CRC） 以太帧内核实现 以太帧头部 在linux系统中，使用struct ethhdr结构体来表示以太网帧的头部。这个struct ethhdr结构体位于#include之中。 #define ETH_ALEN 6 //定义了以太网接口的MAC地址的长度为6个字节 #define ETH_HLAN 14 //定义了以太网帧的头长度为14个字节 #define ETH_ZLEN 60 //定义了以太网帧的最小长度为 ETH_ZLEN + ETH_FCS_LEN = 64个字节 #define ETH_DATA_LEN 1500 //定义了以太网帧的最大负载为1500个字节 #define ETH_FRAME_LEN 1514 //定义了以太网正的最大长度为ETH_DATA_LEN + ETH_FCS_LEN = 1518个字节 #define ETH_FCS_LEN 4 //定义了以太网帧的CRC值占4个字节 struct ethhdr { unsigned char h_dest[ETH_ALEN]; //目的MAC地址 unsigned char h_source[ETH_ALEN]; //源MAC地址 __u16 h_proto ; //网络层所使用的协议类型 }__attribute__((packed)) //用于告诉编译器不要对这个结构体中的缝隙部分进行填充操作； 网络层所使用的协议类型有(常见的类型)： #define ETH_P_IP 0x0800 //IP协议 #define ETH_P_ARP 0x0806 //地址解析协议(Address Resolution Protocol) #define ETH_P_RARP 0x8035 //返向地址解析协议(Reverse Address Resolution Protocol) #define ETH_P_IPV6 0x86DD //IPV6协议 static inline struct ethhdr *eth_hdr(const struct sk_buff *skb) { return (struct ethhdr *)skb_mac_header(skb); } //MAC地址的输出格式。 \"%02x\"所表示的意思是：以16进制的形式输出，每一个16进制字符占一个字节 #define MAC_FMT \"%02x:%02x:%02x:%02x:%02x:%02x\" #define MAC_BUF_LEN 18 //定义了用于存放MAC字符的缓存的大小 #define DECLARE_MAC_BUF(var) char var[MAC_BUF_LEN] //定义了一个MAC字符缓存 填充以太网头部struct ethhdr: ``` int eth_header(struct sk_buff *skb, struct net_device *dev, u16 type, void *daddr, void *saddr, unsigned len) EXPORT_SYMBOL(eth_header); ``` * skb : 将要去修改的struct sk_buff； * dev : 原网络设备 * type: 网络层的协议类型 * daddr:目的MAC地址 * saddr:源MAC地址 * len :一般可为0 ``` int eth_header(struct sk_buff *skb, struct net_device *dev, u16 type, void *daddr, void *saddr, int len) { //将skb->data = skb->data + ETH_ALEN; struct ethhdr *eth = (struct ethhdr*)skb_push(skb, ETH_ALEN); if(type != ETH_P_802_3) eth->proto = htons(type); // htons()将本地类型转换为网络类型 else eth->proto = htons(len); //如果 saddr = NULL的话，以太网帧头中的源MAC地址为dev的MAC地址 if(!saddr) saddr = dev->dev_addr; memcpy(eth->saddr, saddr, ETH_ALEN); if(daddr) { memcpy(eth->daddr, daddr, ETH_ALEN); return ETH_HLEN ; //返回值为14 } return -ETH_HLEN; } ``` 判断网络层协议 ``` __be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev); EXPORT_SYMBOL(eth_type_trans); ``` * skb : 为正在接收的数据包； * dev : 为正在使用的网络设备； * 返回值：为网络字节序列，所以要使用ntohs()进行转换； ``` __be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev) { struct ethhdr *eth; skb->dev = dev; eth = eth_hdr(skb); if(netdev_uses_dsa_tags(dev)) return htons(ETH_P_DSA); if(netdev_uses_trailer_tags(dev)) return htons(ETH_P_TRAILER); if( ntohs(eth->h_proto) >= 1536 ) return eth->h_proto; } ``` 提取mac地址 ``` int eth_header_parse(struct sk_buff *skb, u8 *haddr) EXPORT_SYMBOL(eth_header_parse); ``` * skb : 接收到的数据包； * haddr : 用于存放从接收的数据包中提取的硬件地址； ``` int eth_header_parse(struct sk_buff *skb, u8 *haddr) { struct ethhdr *eth = eth_hdr(skb); memcpy(haddr, eth->h_source, ETH_ALEN); //可知haddr中存放的是源MAC地址； return ETH_ALEN; } ``` mac地址转换 在struct ethhdr中MAC地址为6个字节，并不是我们常见的MAC字符串地址，那么如果将6字节的MAC地址转化为我们常见的MAC字符串地址，使用下面这个函数： char *print_mac(char *buffer, const unsigned char *addr); EXPORT_SYMBOL(print_mac); buffer : 为MAC字符串地址存放的地方； addr : 为6字节MAC地址；char *print_mac(char *buffer, const unsigned char *addr) { // MAC_BUF_SIZE = 18 // ETH_ALEN = 6 _format_mac_addr(buffer, MAC_BUF_SIZE, addr, ETH_ALEN); return buffer; } 重新设置一个网络设备的MAC地址： ``` int eth_mac_addr(struct net_device *dev, void *p); EXPORT_SYMBOL(eth_mac_addr); ``` * dev : 为将要被设置的网络设备； * p : 为socket address; ``` int eth_mac_addr(struct net_device *dev, void *p) { struct sockaddr *addr = p; //用于判断网络设备是否正在运行 if(netif_running(dev)) return -EBUSY; if( !is_valid_ether_addr(addr->sa_data) ) return -ETHADDRNOTAVAIL; memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN); return 0; } ``` struct net_device以太网网络设备进行初始化： void ether_setup(struct net_device *dev); EXPORT_SYMBOL(ether_setup); 分配一个以太网网络设备，并对其进行初始化： ``` struct net_device *alloc_etherdev_mq(int sizeof_priv, u32 queue_count) EXPORT_SYMBOL(alloc_etherdev_mq); ``` ``` struct net_device *alloc_etherdev_mq(int sizeof_priv, unsigned int queue_count) { // ether_setup为对分配的struct net_device进行初始化的函数； //这个ether_setup是内核的导出函数，可以直接使用； return alloc_netdev_mq(sizeof_priv, \"eth%d\", ether_setup, queue_count); } #define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1) ``` MAC地址相关函数 下面的这些函数用于struct ethhdr中的MAC地址的判断： 用于判断一个MAC地址是否为零； ``` 1.int is_zero_ether_addr(const u8 *addr); static inline int is_zero_ether_addr(const u8 *addr) { return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]); } ``` 用于判断addr中的MAC地址是否是组播MAC地址； ``` 2.int is_multicast_ether_addr(const u8 *addr) static inline int is_multicast_ether_addr(const u8 *addr) { //组播MAC地址的判断方法：如果一个MAC地址的最低一位是1的话，则这个MAC地址为组播MAC地址； return (0x01 & addr[0]); } ``` 用于判断addr中的MAC地址是否是广播地址； ``` 3.int is_broadcast_ether_addr(const u8 *addr) static inline int is_broadcast_ether_addr(const u8 *addr) { return ( addr[0] & addr[1] & addr[2] & addr[3] & addr[4] & addr[5] ) == 0xff; } ``` 用于判断addr中的MAC地址是否是有效的MAC地址； 4. int is_valid_ether_addr(const u8* addr) static inline int is_valid_ether_addr(const u8 *addr) { //既不是组播地址，也不为0的MAC地址为有效的MAC地址； return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr); } 用于软件随机产生一个MAC地址，然后存放与addr之中； 5. void random_ether_addr(u8 *addr) static inline void random_ether_addr(u8 *addr) { get_random_bytes(addr, ETH_ALEN); addr[0] & = 0xfe; addr[0] |= 0x02; // IEEE802本地MAC地址 } 判断addr中MAC地址是否是IEEE802中的本地MAC地址。 6.int is_local_ether_addr(const u8 *addr) static inline int is_local_ether_addr(const u8 *addr) { return (0x02 & addr[0]); } 关于IEEE802 MAC地址的须知： 　 IEEE802 LAN6字节MAC地址是目前广泛使用的LAN物理地址。IEEE802规定LAN地址字段的第一个字节的最低位表示I/G（Individual /Group）比特，即单地址/组地址比特。当它为“0”时，表示它代表一个单播地址，而这个位是“1”时，表示它代表一个组地址。 　　IEEE802规定LAN地址字段的第一个字节的最低第二位表示G/L（Globe/Local）比特，即全球/本地比特。当这个比特为“0”时，表 示全球管理，物理地址是由全球局域网地址的法定管理机构统一管理，全球管理地址在全球范围内不会发生地址冲突。当这个比特为“1”时，就是本地管理，局域 网管理员可以任意分配局部管理的网络上的地址，只要在自己网络中地址唯一不产生冲突即可，对外则没有意义，局部管理很少使用。 　　在6个字节的其他46个比特用来标识一个特定的MAC地址，46位的地址空间可表示约70万亿个地址，可以保证全球地址的唯一性。 用于比较两个MAC地址是否相等，相等返回0，不相等返回1； 7.unsigned compare_ether_addr(const u8 *addr1, const u8 *addr2) static inline unsigned compare_ether_addr(const u8 *addr1, const u8 *addr2) { const u16 *a = (const u16*)addr1; const u16 *b = (const u16*)addr2; return ( (a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2]) ) != 0; } 以上的所有的函数可以通过 #include头文件，来直接使用。 IP 上面说到的数据字段是上层协议传递下来的数据，而最常见的上层协议便是ip协议。ip帧的格式如下： ![ip数据包格式](../pic/proto/ip.png) * Version 版本，4位，用来表明IP协议实现的版本号，当前一般为IPv4，即0100，IPv6的为0110。这个字段确保可能运行不同IP版本的的设备之间的兼容性 * IHL 报头长度，4位，以32比特的字来定义IP首部的长度，包括可选项。若该字段的值是5，即5*32=160比特=20字节。此字段最大值为60（15*32/8=60）字节 TOS：服务类型，8位，用于携带提供服务质量特征信息的字段，服务类型字段声明了数据报被网络系统传输时可以被怎样处理。其中前3比特为优先权子字段（Precedence，现已被忽略，各种终端都不采用）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。大多数情况下该TOS会被忽略 Total Length：总长度，16位，指明整个数据报的长度，按字节为计算。最大长度为65535（2^16=65536）字节 Identification：标识，16位，用来唯一地标识主机发送的每一份数据报。IP软件会在`存储器中维持一个计数器`，每产生一个数据段，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。`如数据报由于超过网络的MTU而必须分片时`，这个标识字段的值就被复制到所有的数据报的标识字段中。相同的标识字段的值使`分片后各数据报片最后能正确的重装`成为原来的数据报 Flags：标志，3位，分别是（RF, DF, MF），目前只有DF, MF有效。 * DF（don't fragment），置为0时表示可以分段，置为1是不能被分段； * MF（more fragment），置为0时表示该数据段为最后一个数据段，置为1时表示后面还有被分割分段 Fragment offset：段偏移量，13位，指出较长的分组在分段后，某段在原分组的相对位置。 也就是说相对用户字段的起点，该片从何处开始。 段偏移以8个字节（有3位被flags占据）为偏移单位。这就是，每个分片的长度一定是8字节（64位）的整数倍 Time to live：生存期（TTL），8位，用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃 Protcol：协议，8位，指明ip数据字段中的数据采用上层什么协议封装的。常见的有ICMP（1）、IGMP（2）、TCP（6）、UDP（17） Header Checksum：头部校验和，16位，填充根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和，但不和涉及头部后的数据字段 Source Address：源ip地址，32位，如（192.168.1.2） Destination Address：目的ip地址，32位，如（192.168.1.3） Option：选项，n*32位。用来定义一些可选项：如记录路径、时间戳等。但这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。根据IHL可以得到option的长度 Data：数据，不定长度，但受限于数据报的最大长度（65535）。这是在数据报中要传输的数据。它是一个完整的较高层报文或报文的一个分片 udp udp/tcp帧 UDP协议全称是用户数据报协议（User Datagram Protocol） ，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。由于udp传输不是可靠性服务的，所以帧结构较为简单，而且处理，发送速率高，所以经常被用作音频、视频和普通数据的传输协议，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 src port：源端口，2个字节，是一个大于1023的16位数字，由基于UDP应用程序的用户进程随机选择。 dst port：目的端口，2个字节，指明接收者所用的端口号，一般由应用程序来指定 Length：数据长度，2个字节，指明了包括首部在内的UDP报文段长度 Checksum：检验和，2个字节，指整个UDP报文头和UDP所带的数据的校验和（也包括伪报文头）。伪报文头不包括在真正的UDP报文头中，但是它可以保证UDP数据被正确的主机收到了 Data：数据字段，不定长度，为上层协议封装好的数据 TCP TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文段，最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。 ![tcp数据包格式](../pic/proto/tcp.png) src port：源端口，2个字节，是一个大于1023的16位数字，由基于TCP应用程序的用户进程随机选择 dst port：目的端口，2个字节，指明接收者所用的端口号，一般由应用程序来指定 Sequence number：顺序号，4个字节，用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则 TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，序号到达 (2^32) － 1 后又从 0 开始。当建立一个新的连接时， SYN 标志变 1 ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ） Acknowledgement number：确认号，4个字节，包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效 Offset：报头长度，4位，给出报头中 32bit 字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占 4bit ， 即TCP 最多有 60（15*4） 字节的首部 Resrvd：保留区域，6位，保留给将来使用，目前必须置为 0 Control Flags（6位）控制位包括 URG：为 1 表示紧急指针有效，为 0 则忽略紧急指针值 ACK：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段 PSH：为 1 表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满 RST：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题 SYN：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（ synchronize ） FIN：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流 Window Size：窗口大小，2个字节，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535（2^16 - 1） Checksum：校验和，2个字节，对整个的 TCP 报文段（包括 TCP 头部和 TCP 数据），以 16 位字进行计算所得。这是一个强制性的字段，要求由发送端计算和存储，并由接收端进行验证 Urgent Pointer：紧急指针，2个字节，是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。 只有当URG 标志置 1 时紧急指针才有效 Option and Pad：选项和填充，n*4字节，常见的可选字段是最长报文大小 MSS(Maximum Segment Size) 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以要加填充位，使得报头长度成为整字数 Data：数据，不定长度，为上层协议封装好的数据 附三次握手（建立连接），四次挥手（释放连接） 握手： 1.客户端发送一个 SYN 报文段（ SYN 为 1 ）指明客户端打算连接的服务器的端口，以及初始顺序号（ ISN ） （客户端----》服务端） 2.服务器发回包含服务器的初始顺序号（ ISN ）的 SYN 报文段（ SYN 为 1 ）作为应答。同时，将确认号设置为客户的 ISN 加 1 以对客户的 SYN 报文段进行确认（ ACK 也为 1 ）（服务端----》客户端） 3.客户端必须将确认号设置为服务器的 ISN 加 1 以对服务器的 SYN 报文段进行确认（ ACK 为 1 ），该报文通知目的主机双方已完成连接建立（客户端----》服务端） 挥手： 1.客户端发送一个FIN（FIN为1），用来关闭客户端到服务器的数据传送 （客户端----》服务端） 2.服务器收到这个FIN，它发回一个ACK（ACK为1），确认序号为收到的序号加1 （服务端----》客户端） 3.服务器关闭与客户端的连接，发送一个FIN给客户端 （服务端----》客户端） 4.客户端发回ACK报文确认，并将确认序号设置为收到序号加1 （客户端----》服务端） 四次挥手的目的在于如果客户端因为数据发送完毕而想要关闭，便发送FIN。服务端收到FIN后，但可能还存在数据需要发给客户端，所以服务端先发ACK作为应答。当服务端也发送完毕之后，再发回FIN作为关闭连接。客户端收到FIN后，发送ACK，然后关闭连接。 http http报文 http属于应用层协议，自由度更高，是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。报文类型可以分为两种：请求报文和响应报文 http请求报文： 写成段式的话是： 1.请求行 请求行包括了请求方法、URL、协议版本，它们之间用空格分隔，且都不定长度，所以我们输入的URL是不允许带有空格的。 请求方法：常用的POST（将表单数据存入请求体里面，多数用于上传数据）, GET（将请求参数都放置在URL+?后，参数之间用&连接，用于获取数据）, HEAD（服务端只返回响应头，所以处理响应速度快，用于检测请求是否可用）。 2.请求头 每一行以键/值的形式写入，键值间用:分割，多个值之间以;分割，每行以回车符换行符为结束。常见的键有：User-Agent：产生请求的浏览器类型；Accept：客户端可识别的内容类型列表；Host：请求的主机名，允许多个域名同处一个IP地址；Range：指定请求实体的一个或者多个子范围，采用多线程下载时可以设置该键。要注意请求头与请求体间的一个空行，它表示通知服务端没有更多请求头了，下面的都是请求体。 3.请求体 请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。 http响应报文： 写成段式： 1.状态行 状态包括协议版本，状态码，状态码描述，常见的一个状态行的例子是（ HTTP/1.1 200 OK ），200表示请求正常，更多的状态码可以查有关资料。 2.响应头 与请求头类似，通过键/值的形式向客户端传递关键消息，常见的有：Content-Type：用于向接收方指示实体的介质类型；Content-Range：用于向接收方指示实体的传送范围；Content-Length：用于向接收方指示实体的传送长度；Date：传送时系统的日期与时间。 3.响应体 服务端真正返回的文本数据，如果客户端请求一个网页的话，该数据段将填充请求的html文本。给一个响应头的例子： [html] view plain copy HTTP/1.1 200 OKDate: Thu, 28 Apr 2016 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122 ＜html＞＜head＞＜title＞Test＜/title＞＜/head＞＜body＞ hello＜/body＞＜/html＞ 总结 如果分析一个http请求的话，按照因特网五层协议，得到的数据流将是这样的： Copyright © jsliang.top 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-10 20:49:48 "}}